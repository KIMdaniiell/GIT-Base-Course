# 2.2, 2.4, 2.5, 2.7, 2.8, 2.9 Git – Основы – Индексирование, коммиты, просмотр изменений

> [!IMPORTANT]
> В Git **двуступенчатая система коммитов**.
> 
> 1. При создании нового файла в _рабочем дереве_ Git посчитает его неотслеживаемым (**_untracked_**)  
>    и такие изменения **НЕ** попадают из _рабочего дерева_ в _репозиторий_ напрямую.
> 2. Вместо этого изменения сначала регистрируются в ***индексе*** (*индексация*).  
>    Это можно рассматривать как способ *«подтверждения»* изменений перед совершением *коммита*.  
>    После попадания в _индекс_ файлы становятся подготовленными к коммиту (**_staged_**):
> 3. Все подготовленные изменения или их часть можно закомитить в _репозиторий_. 

![Иллюстрация жизненного цикла изменений проекта](https://habrastorage.org/webt/tc/hz/vd/tchzvdfzhvhht5akhcdf93fnhso.png)
___

## Просмотр изменений

```powershell
~~~> git status
```
Отображаемая информация:
+ Текущая _ветка_ ;
+ **Changes to be committed** - файлы находятся в индексе, т.е. подготовленные для следующего коммита;  
  (файлы в _индексе_ и в _HEAD_-коммите не синхронизированы)
+ **Changes not staged for commit** - файлы в *рабочем дереве*  
 не синхронизированые либо с _репозиторием_, либо с _индексом_,  
  т.е. их последняя версия не была проиндексирована ;
+ **Untracked files** - файлы в *рабочем дереве* которые Git не отслеживает,  
  т.е. о которых не знает ни _репозиторий_, ни _индекс_;
  
<details> <summary>Пример:</summary>

```powershell
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   file3
        new file:   file5

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2
        modified:   file5

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file4
```  
</details>


## Индексирование изменений

```powershell
~~~> git add
        [--force | -f]  ------------------ # Позволяет игнорировать предупреждения и обходить `.gitignore` ;
        [--patch | -p]  ------------------ # Позволяет индексировать изменения в файле пофрагментно (y/n/s/...) ;
        [--all | -A]  -------------------- # Позволяет проиндексировать все файлы проекта,
                                           # кроме тех, что указаны в `.gitignore` ;
        [имя_файла | директория | регулярка]
```
+ При указании **директории** в `git add` в _индекс_ добавятся **все** содержащиеся в ней файлы ;
  + Чтобы Git не учитывал **лишние** файлы, их следует перечислить в `.gitignore` в корне проекта ;
+ Git не умеет работать с **пустыми директориями** ;
  + Чтобы добавить пустую директорию можно предварительно создать в ней пустой файл  
    (обычно его называют `.gitkeep`) ;
+ Неочевидно то, что если файл в _рабочей директории_ был удален, то это также нужно проиндексировать командой `git add`;

```powershell
~~~> git rm
        [--force | -f]  ------------------ # Позволяет игнорировать предупреждения и удалять модифицированные файлы,
                                           # которые не сохранены в репозитории
                                           # (т.е. без возможности эти изменения восстановить) ;
        [-r]  ---------------------------- # Рекурсивное удаление директорий ;
        [--cashed]  ---------------------- # Удаление только на уровне индекса (в рабочей директории файл сохраняется) ;
        [имя_файла | директория | регулярка]
```
+ Команда `git rm *file*` делает то же, что и последовательность `rm *file*` и `git add *file*` ;

```powershell
~~~> git mv
        [--force | -f]  ------------------ # Позволяет игнорировать предупреждения
                                           # и пререименовывать/перемещать файлы даже если
                                           # такой таргет уже существует ;
        [изменяемый_файл] [таргет]
```
+ Команда `git mv *file1* *file2*` делает то же, что и последовательность `cp *file1* *file2*`, `git rm *file1*` и `git add *file2*` ;


## Создание коммита

```powershell
~~~> git commit  
        [--all | -a]  -------------------- # Позволяет коммитить изменения пропуская стадию индексации
                                           # т.е. выполняет `git add` и `git rm` 
                                           # для всех измененных файлов вместо пользователя
                                           # (относится к тем файлам, о которых знает Git
                                           # - т.е. для операций модификации и удаления файлов) ;
        [--amend]  ----------------------- # Позволяет перезаписать последний коммит в ветке ;
        [--message | -m] [текст_коммита]   
        [файлы]                            
```

+ Новый коммит становится дочерним элементом _HEAD_ ;
+ При указании файлов в конце, они закоммитятся:
  + это произойдет даже если они не были проиндексированны ;
  + причем остальные изменения не пропадут и останутся проиндексированными  
    и их можно будет применить потом с помощью обычного `git commit`  
    (помогает управлять порядком изменений) ;

<details> <summary>Информация об авторах коммита:</summary>

Можно задать с помощью флагов команды `git commit`:
+ `        [--author]=[имя_автора]` ;
+ `        [--date]=[авторская_дата]` ;

Можно задать с помощью переменных окружения:
+ Информация об авторе:
  + GIT_AUTHOR_NAME
  + GIT_AUTHOR_EMAIL
  + GIT_AUTHOR_DATE
+ Информация о коммитере:  
  + GIT_COMMITTER_NAME
  + GIT_COMMITTER_EMAIL
  + GIT_COMMITTER_DATE

Переменные окружения будут переписывать данные заданные параметрами конфигурации:
+ _user.name_
+ _user.email_
+ _committer.name_
+ _committer.email_
</details>

<details> <summary>Вывод (оформление коммита):</summary>

```powershell
<type>[<scope>]: <subject>

<body>

<footer>
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Changes to be committed:
#       modified:   file5
#
# Untracked files:
#       file4
#
```

> [!NOTE]  
> Редактор для ввода информации о коммите можно поменять.  
>  Для этого необходимо сконфигурировать параметр `core.editor`
>  ```powershell
>  ~~~> whereis vim
>  vim: /usr/bin/vim /etc/vim /usr/share/vim /usr/share/man/man1/vim.1.gz
>  ```
>  ```powershell
>  ~~~> git config --global core.editor /usr/bin/vim
>  ```
>  
  
</details>
  
## Просмотр объекта в Git

```powershell
~~~> git show
        [--pretty]=[PRETTY_FORMAT]  ------ # Определяет количество выводимых метаданных о коммите ;
        [--quiet]  ----------------------- # Убирает инфу об изменениях из вывода ;
        [коммит] | [коммит_А...коммит_Б]
```

+ По-умолчанию `git show` выводит информацию о _HEAD_ ;

<details> <summary>Форматы вывода:</summary>

+ _oneline_:
  + хэш ;
  + заголовок коммита ;
  + инфа об изменениях ;
+ _short_:
  + хэш ;
  + автор ;
  + заголовок коммита ;
  + инфа об изменениях ;
+ _medium_ (по-умолчанию):
  + хэш ; 
  + автор + авторская дата ;
  + заголовок коммита + _body_ и _footer_ коммита ;
  + инфа об изменениях ;
+ _full_:
  + хэш ; 
  + автор + коммитер ;
  + заголовок коммита + _body_ и _footer_ коммита ;
  + инфа об изменениях ;
+ _fuller_
  + хэш ; 
  + автор + авторская дата + коммитер + дата коммита ;
  + заголовок коммита + _body_ + _footer_ коммита ;
  + инфа об изменениях ;
+ и другие (о них `git help show`) ;

</details>

## Просмотр истории

```powershell
~~~> git log
        [--pretty]=[PRETTY_FORMAT] ------- # см. `git show` ;
        [--oneline]  --------------------- # Cокращение от `--pretty=oneline` ;
        [--no-decorate]  ----------------- # Скрывает названия веток и еще какой-то текст ;
        [начальный_коммит]
```
+ Мой любимый алиас `alias.logon=!git log --oneline --no-decorate`
