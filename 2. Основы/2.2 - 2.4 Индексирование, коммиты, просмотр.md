# 2.2 - 2.4 Git – Основы – Индексирование, коммиты, просмотр

> [!IMPORTANT]
> В _Git_ изменения НЕ попадают из рабочего дерева в репозиторий напрямую.
> 
> При создании нового файла Git посчитает его неотслеживаемым (**_untracked_**).

> [!NOTE]
> Вместо этого изменения сначала регистрируются в ***индексе*** (*индексация*).  
> Это можно рассматривать как способ *«подтверждения»* ваших изменений перед совершением *коммита*.  
>
> После попадания в индекс файлы становятся подготовленными к коммиту (**_staged_**):

![Иллюстрация жизненного цикла изменений проекта](https://habrastorage.org/webt/tc/hz/vd/tchzvdfzhvhht5akhcdf93fnhso.png)


Изменения могут быть:
+ В *рабочем дереве*  
  &ensp; (не синхронизированы файлы в *рабочем дереве* и *индекс*) ;
+ В *индексе*  
  &ensp; (не синхронизированы *индекс* и *HEAD-коммит*) ;

## Просмотр изменений

```powershell
~~~> git
        status
```

<details> <summary>Вывод (инфа об изменениях):</summary>

```powershell
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   file3
        new file:   file5

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2
        modified:   file5

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file4
```

Отображаемая информация:
+ Текущая _ветка_ ;
+ ***Changes to be committed*** - файлы находятся в индексе, т.е. подготовленные для следующего коммита ;
+ ***Changes not staged for commit*** - файлы в *рабочем дереве* либо не синхронизированые с репозиторием,  
 либо не синхронизированые с *индексом* ;
+ ***Untracked files*** - файлы в *рабочем дереве*, о которых не знает ни _репозиторий_, ни _индекс_;
  
</details>



## Индексирование изменений

```powershell
~~~> git
        add [имя_файла | директория | регулярка]
```

```powershell
~~~> git
        rm 
        [--cached]
        [имя_файла | директория | регулярка]
```

## Создание коммита

```powershell
~~~> git
        commit
        [--dry-run]
        [--message|-m] [инфа_о_коммите_заместо_полноценного_оформления]
        [--author]=[имя_автора]
        [--date]=[авторская_дата]
        [файлы]
```

+ новый коммит становится дочерним элементов _HEAD_ ;
+ флаг `-a` позволяет коммитить изменения пропуская стадию индексации,  
  т.е. выполняет `git add` и `git rm` вместо пользователя  
 (относится к тем файлам, о которых знает Git - т.е. для операций модификации и удаления файлов) ;
+ флаг `--amend` позволяет перезаписать последний коммит в ветке ;
+ при указании файлов в конце, коммититься будут только они.  
  Причем остальные изменения не пропадут и останутся проиндексированными - их можно будет применить потом с помощью обычного `git commit`  
  (помогает управлять порядком изменений) ;

<details> <summary>Информация об авторах коммита:</summary>

Можно задать с помощью переменных окружения:
+ Информация об авторе:
  + GIT_AUTHOR_NAME
  + GIT_AUTHOR_EMAIL
  + GIT_AUTHOR_DATE
+ Информация о коммитере:  
  + GIT_COMMITTER_NAME
  + GIT_COMMITTER_EMAIL
  + GIT_COMMITTER_DATE

Переменные окружения будут переписывать данные заданные параметрами конфигурации:
+ _user.name_
+ _user.email_
+ _committer.name_
+ _committer.email_
  
</details>

<details> <summary>Вывод (оформление коммита):</summary>

```powershell
<type>[<scope>]: <subject>

<body>

<footer>
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Changes to be committed:
#       modified:   file5
#
# Untracked files:
#       file4
#
```

> [!NOTE]  
> Редактор для ввода информации о коммите можно поменять.  
>  Для этого необходимо сконфигурировать параметр `core.editor`
>  ```powershell
>  ~~~> whereis vim
>  vim: /usr/bin/vim /etc/vim /usr/share/vim /usr/share/man/man1/vim.1.gz
>  ```
>  ```powershell
>  ~~~> git config --global core.editor /usr/bin/vim
>  ```
  
</details>
  
## Просмотр объекта в Git

```powershell
~~~> git
        show
        [--pretty] [PRETTY_FORMAT]
        [коммит] | [коммит_А...коммит_Б]
```

+ по-умолчанию `git show` выводит информацию о _HEAD_ ;

<details> <summary>Форматы вывода:</summary>

+ _oneline_:
  + хэш ;
  + заголовок коммита ;
  + инфа об изменениях ;
+ _short_:
  + хэш ;
  + автор ;
  + заголовок коммита ;
  + инфа об изменениях ;
+ _medium_ (по-умолчанию):
  + хэш ; 
  + автор + авторская дата ;
  + заголовок коммита + _body_ и _footer_ коммита ;
  + инфа об изменениях ;
+ _full_:
  + хэш ; 
  + автор + коммитер ;
  + заголовок коммита + _body_ и _footer_ коммита ;
  + инфа об изменениях ;
+ _fuller_
  + хэш ; 
  + автор + авторская дата + коммитер + дата коммита ;
  + заголовок коммита + _body_ + _footer_ коммита ;
  + инфа об изменениях ;
+ и другие (о них `git help show`) ;

</details>
