# 2.2 - 2.5 Git – Основы – Индексирование, коммиты, просмотр

> [!IMPORTANT]
> В Git **двуступенчатая система коммитов**.
> 
> 1. При создании нового файла в _рабочем дереве_ Git посчитает его неотслеживаемым (**_untracked_**)  
>    и такие изменения **НЕ** попадают из _рабочего дерева_ в _репозиторий_ напрямую.
> 2. Вместо этого изменения сначала регистрируются в ***индексе*** (*индексация*).  
>    Это можно рассматривать как способ *«подтверждения»* изменений перед совершением *коммита*.  
>    После попадания в _индекс_ файлы становятся подготовленными к коммиту (**_staged_**):
> 3. Все подготовленные изменения или их часть можно закомитить в _репозиторий_. 

![Иллюстрация жизненного цикла изменений проекта](https://habrastorage.org/webt/tc/hz/vd/tchzvdfzhvhht5akhcdf93fnhso.png)
___

## Просмотр изменений

```powershell
~~~> git status
```
Отображаемая информация:
+ Текущая _ветка_ ;
+ **Changes to be committed** - файлы находятся в индексе, т.е. подготовленные для следующего коммита;  
  (файлы в _индексе_ и в _HEAD_-коммите не синхронизированы)
+ **Changes not staged for commit** - файлы в *рабочем дереве*  
 не синхронизированые либо с _репозиторием_, либо с _индексом_,  
  т.е. их последняя версия не была проиндексирована ;
+ **Untracked files** - файлы в *рабочем дереве* которые Git не отслеживает,  
  т.е. о которых не знает ни _репозиторий_, ни _индекс_;
  
<details> <summary>Пример:</summary>

```powershell
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   file3
        new file:   file5

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2
        modified:   file5

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file4
```  
</details>


## Индексирование изменений

```powershell
~~~> git add
        [--force | -f]  ------------------ # Позволяет игнорировать предупреждения и обходить `.gitignore` ;
        [--patch | -p]  ------------------ # Позволяет индексировать изменения в файле пофрагментно (y/n/s/...) ; 
        [имя_файла | директория | регулярка]
```
+ При указании **директории** в `git add` в _индекс_ добавятся **все** содержащиеся в ней файлы ;
  + Чтобы Git не учитывал **лишние** файлы, их следует перечислить в `.gitignore` в корне проекта ;
+ Git не умеет работать с **пустыми директориями** ;
  + Чтобы добавить пустую директорию можно предварительно создать в ней пустой файл  
    (обычно его называют `.gitkeep`) ;

```powershell
~~~> git rm 
        [--cached]
        [имя_файла | директория | регулярка]
```

## Создание коммита

```powershell
~~~> git commit  
        [--all | -a]  -------------------- # позволяет коммитить изменения пропуская стадию индексации
                                           # т.е. выполняет `git add` и `git rm` 
                                           # для всех измененных файлов вместо пользователя
                                           # (относится к тем файлам, о которых знает Git
                                           # - т.е. для операций модификации и удаления файлов) ;
        [--amend]  ----------------------- # позволяет перезаписать последний коммит в ветке ;
        [--message | -m] [текст_коммита]   
        [файлы]                            
```

+ новый коммит становится дочерним элементов _HEAD_ ;
+ при указании файлов в конце, коммититься будут только они.  
  Причем остальные изменения не пропадут и останутся проиндексированными - их можно будет применить потом с помощью обычного `git commit`  
  (помогает управлять порядком изменений) ;

<details> <summary>Информация об авторах коммита:</summary>

Можно задать с помощью флагов команды `git commit`:
+ `        [--author]=[имя_автора]` ;
+ `        [--date]=[авторская_дата]` ;

Можно задать с помощью переменных окружения:
+ Информация об авторе:
  + GIT_AUTHOR_NAME
  + GIT_AUTHOR_EMAIL
  + GIT_AUTHOR_DATE
+ Информация о коммитере:  
  + GIT_COMMITTER_NAME
  + GIT_COMMITTER_EMAIL
  + GIT_COMMITTER_DATE

Переменные окружения будут переписывать данные заданные параметрами конфигурации:
+ _user.name_
+ _user.email_
+ _committer.name_
+ _committer.email_
</details>

<details> <summary>Вывод (оформление коммита):</summary>

```powershell
<type>[<scope>]: <subject>

<body>

<footer>
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Changes to be committed:
#       modified:   file5
#
# Untracked files:
#       file4
#
```

> [!NOTE]  
> Редактор для ввода информации о коммите можно поменять.  
>  Для этого необходимо сконфигурировать параметр `core.editor`
>  ```powershell
>  ~~~> whereis vim
>  vim: /usr/bin/vim /etc/vim /usr/share/vim /usr/share/man/man1/vim.1.gz
>  ```
>  ```powershell
>  ~~~> git config --global core.editor /usr/bin/vim
>  ```
>  
  
</details>
  
## Просмотр объекта в Git

```powershell
~~~> git show
        [--pretty] [PRETTY_FORMAT]
        [коммит] | [коммит_А...коммит_Б]
```

+ по-умолчанию `git show` выводит информацию о _HEAD_ ;

<details> <summary>Форматы вывода:</summary>

+ _oneline_:
  + хэш ;
  + заголовок коммита ;
  + инфа об изменениях ;
+ _short_:
  + хэш ;
  + автор ;
  + заголовок коммита ;
  + инфа об изменениях ;
+ _medium_ (по-умолчанию):
  + хэш ; 
  + автор + авторская дата ;
  + заголовок коммита + _body_ и _footer_ коммита ;
  + инфа об изменениях ;
+ _full_:
  + хэш ; 
  + автор + коммитер ;
  + заголовок коммита + _body_ и _footer_ коммита ;
  + инфа об изменениях ;
+ _fuller_
  + хэш ; 
  + автор + авторская дата + коммитер + дата коммита ;
  + заголовок коммита + _body_ + _footer_ коммита ;
  + инфа об изменениях ;
+ и другие (о них `git help show`) ;

</details>
